<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="唯一特长是打退堂鼓">
    <meta name="keyword" content="null">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="http://o6vut8vrh.bkt.clouddn.com/avatar.png">
    <link rel="alternate" type="application/atom+xml" title="咸鱼Jackie" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        机器学习的方法来帮助进行大图可视化｜叫Jackie的咸鱼
        
    </title>

    <link rel="canonical" href="http://jackieanxis.github.io/blog/2017/09/03/机器学习的方法来帮助进行大图可视化/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/blog/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/blog/css/syntax.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<style>

    header.intro-header {
        background-image: url('http://o6vut8vrh.bkt.clouddn.com/background.png')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/blog/">
                <span class="brand-logo">
                    咸鱼Jackie
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/blog/">Home</a>
                    </li>
					
                    
                        
							
								
							
						
                    
                        
							
                        <li>
                            <a href="/blog/tags/">tags</a>
                        </li>
							
						
                    
					
					
						<li>
							<a href="/blog/blog/about">About</a>
						</li>
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="http://o6vut8vrh.bkt.clouddn.com/background.png">


<style>
    
    header.intro-header {
        background-image: url('http://o6vut8vrh.bkt.clouddn.com/background.png')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>机器学习的方法来帮助进行大图可视化</h1>
                    
                    <span class="meta">
                         作者 Jackie Anxis
                        <span>
                          日期 2017-09-03
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/blog/tags/#可视化"
                           title="可视化">可视化</a>
                        
                        <a class="tag" href="/blog/tags/#论文"
                           title="论文">论文</a>
                        
                        <a class="tag" href="/blog/tags/#阅读笔记"
                           title="阅读笔记">阅读笔记</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            机器学习的方法来帮助进行大图可视化
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h1 id="机器学习的方法来帮助进行大图可视化"><a href="#机器学习的方法来帮助进行大图可视化" class="headerlink" title="机器学习的方法来帮助进行大图可视化"></a>机器学习的方法来帮助进行大图可视化</h1><ul>
<li>论文原标题：What Would a Graph Look Like in This Layout? A Machine Learning Approach to Large Graph Visualization</li>
</ul>
<p>为了为图数据挑选一个合适的布局，论文提出了一种机器学习方法，基于用graph kernel计算的图拓扑相似度。这种方法可以显示图结构在不同的布局方法下的外观，并且可以估计这些图在布局下的美学度量。文章的贡献点是提出了一个可以用来设计graph kernel的框架。</p>
<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><ul>
<li><p><strong>背景</strong>：为了帮助用户找到一个合适的节点链接图布局，从而来描述一个图的结构，我们需要计算这个图数据在这种布局方法下的<strong>布局结果</strong>以及它的<strong>美学指标</strong>。</p>
</li>
<li><p><strong>问题</strong>：一般的计算方法，对大图而言，计算以上两者开销太大。</p>
</li>
<li><p><strong>方案</strong>：文章提出用kernelized machine learning的方法来预测图的布局结果和美学指标，在保证一定精度的情况下，大量降低时间复杂度。</p>
<p>而kernelized machine learning需要一个合适的kernel。这个kernel是用来比较图与图之间的相似度，从而驱动机器学习。</p>
<p>kernel，或者叫做kernel function，是一个比较两个输入之间相似度的函数$\chi \times \chi \mapsto \Bbb{R}$，kernel function k，经常被定义为特征空间$\cal{H}$中两个向量的内积：</p>
<p>$k(x, x’) = \langle\phi(x), \phi(x’)\rangle = \langle\bf{x}, \bf{x’}\rangle$</p>
<p>其中$\phi$是输入$x$到特征向量$\bf{x}$的映射，$\chi\mapsto\cal{H}$</p>
</li>
<li><p><strong>基本假设</strong>：在给定的相同的布局方法下，如果图有相似的拓扑结构，那么他们就会有相似的布局结果。</p>
</li>
</ul>
<h3 id="拓扑相似度比较方法——graph-kernel"><a href="#拓扑相似度比较方法——graph-kernel" class="headerlink" title="拓扑相似度比较方法——graph kernel"></a>拓扑相似度比较方法——graph kernel</h3><ul>
<li><p><strong>老方法</strong>：graph kernel通过将图递归分解成一系列子结构，通过这些子结构的比较来评价两个图的相似度。这些子结构可以是：walks, shortest path, subtrees, cycles和graphlets。</p>
</li>
<li><p><strong>存在问题</strong>：因为很多graph kernel不适合大图，因为时间复杂度的问题或者不适合未标记图（节点之间除了连通性以外没有其他区别的话，就把这个图成为未标记的，unlabeled）。</p>
</li>
<li><p><strong>新方法</strong>：文章采用了graphlet kernel，其特征向量采用的是graphlet（下文称之为图元）的频率分布向量。</p>
<p>图元是一种小的异构的导出子图。导出的（induced）的定义是：对于$G=(V, E)$，$V$的一个子集$V1$，以$G$中两个端点都在$V1$中的边组成边集$E1$，和$V1$构成的的图为$G$的$V1$导出子图。</p>
<h6 id="图1：3、4、5节点的所有连通的图元"><a href="#图1：3、4、5节点的所有连通的图元" class="headerlink" title="图1：3、4、5节点的所有连通的图元"></a>图1：3、4、5节点的所有连通的图元</h6><p>下面列举了节点数为3/4/5的所有连通的图元：</p>
<p><img src="http://o6vut8vrh.bkt.clouddn.com/17-9-1/21892478.jpg" alt=""></p>
</li>
<li><p><strong>基本思想</strong>：通过计数图中相互独立的图元的个数，统计它们的频率分布，将图元的频率分布向量，作为图的特征向量，用kernel计算两个图的特征向量的内积，就可以比较图之间的相似度。</p>
</li>
</ul>
<h2 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h2><h3 id="设计graphlet-kernel的框架"><a href="#设计graphlet-kernel的框架" class="headerlink" title="设计graphlet kernel的框架"></a>设计graphlet kernel的框架</h3><p>一个graphlet kernel的设计，需要以下步骤：</p>
<ol>
<li>采样图元，统计个数（采样方法）</li>
<li>计算图元频率向量（频率计算方法）</li>
<li>求两个图元频率向量的内积（内积方法）</li>
</ol>
<h4 id="2-1采样图元"><a href="#2-1采样图元" class="headerlink" title="2-1采样图元"></a>2-1采样图元</h4><p>穷举所有图元开销过大，要穷举所有k节点图元，开销是$O(|V|^K)$。故而采用随机采样方法，主要有两种：</p>
<ul>
<li>随机节点采样（Random vertex sampling (RV)）：为了找一个k节点图元，通过随机找k个节点，用它们原有的边连接。但对于真实世界的网络，$|E|&lt;&lt;O(|V|^2)$，那么大部分随机采样的图元将会是不连通的。当只想采样连通图元的话，就需要很多轮迭代才能采到足够数量的图元，时间开销会很大。</li>
<li>随机游走采样（Random walk sampling (RW)）：基于随机游走的采样方法，还没被用于设计graphlet kernel，这种采样方法可以用来采集连通图元。</li>
</ul>
<h4 id="2-2计算图元频率向量"><a href="#2-2计算图元频率向量" class="headerlink" title="2-2计算图元频率向量"></a>2-2计算图元频率向量</h4><p>图元频率被定义为每种图元$g_{i}$的相对频率，以此构成的频率向量，本质上就是图的一个特征向量。一共有两种方法用来计算频率向量：</p>
<ul>
<li><p>线性比例变换（linear scale, LIN）：也被叫做图元浓度（graphlet concentration），是每种图元在图中的百分比，一些工作用每种图元的加权数量$w_i$来定义它：</p>
<p>$x_i = \frac{w_i}{\sum w_i}$</p>
</li>
<li><p>对数比例变换（Logarithmic scale, LOG）：类似于节点度分布，图元频率分布也经常服从幂律分布，这会导致缺少关键信息的图元会远高于那些信息丰富的图元，故而一些工作用了一个对数变换来解决这个问题，其中$w_b$是一个基础权重，来防止$log(0)$:</p>
<p>$x_i = log(\frac{w_i+w_b}{\sum (w_i+w_b)})$</p>
</li>
</ul>
<h4 id="2-3定义内积"><a href="#2-3定义内积" class="headerlink" title="2-3定义内积"></a>2-3定义内积</h4><p>文章引用了以下几个计算特征空间中的内积的kernel函数，内积结果即为两个图的相似度：</p>
<ul>
<li><p>余弦相似度（Cosine similarity，COS）：现有最多的graphlet kernel使用欧氏空间中的两个向量的点积后产生的点积产生的矩阵的归一化结果作为核函数，也就是两个向量的余弦相似度，也是两个向量的</p>
<p>$\langle \bf{x, x’} \rangle = \frac{\bf{x \cdot x’^T}}{||\bf x|||| \bf x’ ||}$</p>
</li>
<li><p>高斯径向基函数核（Gaussian radial basis function kernel, RBF）：经常被用在机器学习中，$\sigma$是一个自由参数</p>
<p>$\langle \bf{x, x’} \rangle = exp(-\frac{||\bf{x - x’}||^2}{2\sigma ^ 2})$</p>
<ul>
<li>拉普拉斯核（Laplacian kernel，LAPLACIAN）：是RBF核的一种变种：</li>
</ul>
<p>$\langle \bf{x, x’} \rangle = exp(-\frac{||\bf{x - x’}||_1}{\sigma})$</p>
<p>​</p>
</li>
</ul>
<h2 id="三、用途"><a href="#三、用途" class="headerlink" title="三、用途"></a>三、用途</h2><h3 id="3-1预测图的布局结果（WGL）"><a href="#3-1预测图的布局结果（WGL）" class="headerlink" title="3-1预测图的布局结果（WGL）"></a>3-1预测图的布局结果（WGL）</h3><p>文章把这个方法称为<strong>WGL</strong>（What Would a Graph Look Like in This Layout? ）</p>
<p>文章基于相似度，设计了一个类似KNN的最近邻算法，用来找出和输入图$G_{input}$拓扑结构最相似的k个图，并展示他们已存在的布局结果给用户。用户就可以通过观察这些拓扑相似的图来预测$G_{input}$的结果，步骤一共分三步：</p>
<ol>
<li>计算准备好的已存在的图（每个图都预先计算好了布局结果）和输入图$G_{input}$的相似度</li>
<li>移除不满足约束条件的图（因为有些图，虽然它的特征向量和$G_{input}$很相似，但是因为节点过多或者过少，事实上应该不算做相似图，比如<a href="#图2：元频率分布的四个例子">图2</a>，文章中设置了一个约束条件，即相似图的节点数，不能多于$G_{input}$的2倍，或者少于$G_{input}$的1/2）</li>
<li>选出K个最相似图</li>
</ol>
<h6 id="图2：图元频率分布的四个例子"><a href="#图2：图元频率分布的四个例子" class="headerlink" title="图2：图元频率分布的四个例子"></a>图2：图元频率分布的四个例子</h6><p>下图中，x轴表示了图元的种类，y轴表示了图元的频率。图a和c的图元频率分布相似，且节点数量也相近，我们可以认为它们两者是拓扑相似图；但是，虽然图b和d的图元频率分布相似，但是因为节点数量相差过大，它们事实上不应该算作相似图。</p>
<p><img src="http://o6vut8vrh.bkt.clouddn.com/17-9-3/37262850.jpg" alt=""></p>
<h3 id="3-2预测图的美学指标（EAM）"><a href="#3-2预测图的美学指标（EAM）" class="headerlink" title="3-2预测图的美学指标（EAM）"></a>3-2预测图的美学指标（EAM）</h3><p>文章把这个方法称为<strong>EAM</strong>(Estimating Aesthetic Metrics)</p>
<p>美学指标是用来评判一幅图布局的良好状况的一系列指标，既然计算一个图的实际布局结果非常耗时，我们可以训练一个回归模型，用于预测某个新的输入图的美学指标，而不用实际计算布局结果，训练步骤一共分三步：</p>
<ol>
<li>准备训练数据（一系列的图，以及它们在不同布局下的布局结果和相关的美学指标）</li>
<li>用graph kernel计算训练数据中的图和图之间的相似度</li>
<li>训练回归模型</li>
</ol>
<p>之后，我们就可以通过计算新的输入图和训练数据中的其他图的相似度，用已有的回归模型，估算输入图的美学指标。</p>
<h2 id="四、评估"><a href="#四、评估" class="headerlink" title="四、评估"></a>四、评估</h2><h3 id="4-1估算布局的美学指标"><a href="#4-1估算布局的美学指标" class="headerlink" title="4-1估算布局的美学指标"></a>4-1估算布局的美学指标</h3><h4 id="4-1-1评估目的"><a href="#4-1-1评估目的" class="headerlink" title="4-1-1评估目的"></a>4-1-1评估目的</h4><p>为了回答一下几个问题：</p>
<ol>
<li>精确？在不计算实际布局的情况下，是否能够精确地估算布局的美学指标？</li>
<li>快速？能否快速的获得估算结果？</li>
<li>更强？由上述框架产生的graph kernel是否能够在计算时间和精度方面都优于最先进的graph kernel？</li>
</ol>
<h4 id="4-1-2实验设计"><a href="#4-1-2实验设计" class="headerlink" title="4-1-2实验设计"></a>4-1-2实验设计</h4><h5 id="4-1-2-1数据集"><a href="#4-1-2-1数据集" class="headerlink" title="4-1-2-1数据集"></a>4-1-2-1数据集</h5><ol>
<li>收集了包括并不限于社交网络、网络文档网络、几何网络的3700个图。在不失一般性的情况下，把具有多个连通部件的图拆成几个分离的图（一个连通部件对应一个图）。</li>
<li>之后剔除少于100个节点的图，因为这些图的计算会特别快，从而影响实验结果。</li>
<li>最后剩下8263个图，节点数范围从100~一亿一千万，边数范围从100~18亿。因为某些图在计算布局的时间上花了10天以上或者内存跑完了，这些图就被抛弃了。</li>
</ol>
<h5 id="4-1-2-2kernel选取"><a href="#4-1-2-2kernel选取" class="headerlink" title="4-1-2-2kernel选取"></a>4-1-2-2kernel选取</h5><p>一共十二个（2×2×3）核函数，是由<a href="#设计graphlet-kernel的框架">生成graph kernel的框架</a>中提到的2种采样方法（随机选点RV和随机游走RW）×2种图元频率计算方法（线性LIN和对数LOG）×3种内积函数（COS, RBF和LAPLACIAN）组合而成。</p>
<p>并且，选取了一个目前已有的最先进的graph kernel，DGK（Deep Graph Kernel）进行比较。</p>
<p>对于所有的kernel，每幅图都采样了10000个有三个、四个、五个节点的图元（一共49种图元，其中29种是连通的，如<a href="#图1. 3、4、5节点的所有连通的图元">图1</a>所示）。因为计算开销的问题，这三种图元用的比较多，而6节点以上的图元一般比较稀有。并且RW采样只考虑连通图元，RV采样考虑非连通和连通的图元。</p>
<h5 id="4-1-2-3布局方法选取"><a href="#4-1-2-3布局方法选取" class="headerlink" title="4-1-2-3布局方法选取"></a>4-1-2-3布局方法选取</h5><p>这里只考虑二维平面，用直线绘制边的布局方法。</p>
<p>因为时间问题，不可能计算所有的布局方法。所以根据(1)使用的广泛性，(2)是否有公开实现，(3)是否被证明优于同类其他方法，文章选取了5种布局方法类别中的8个具有代表性的布局方法。</p>
<ul>
<li><strong>力引导（Force-directed methods）</strong>：电子模型中选取了Fruchterman-Reingold (FR)，能量模型中选取了Kamada-Kawai (KK)</li>
<li><strong>基于降维的方法（Dimension reduction based method）</strong>：选取了High-Dimensional Embedder (HDE)</li>
<li><strong>谱方法（Spectral method）</strong>：选取了Koren的方法</li>
<li><strong>多层方法（Multi-Level methods）</strong>：选了sfdp和FM3</li>
<li><strong>基于聚类的方法（Clustering based methods）</strong>：选了Treemap based layout和the Gosper curve based layout</li>
</ul>
<h5 id="4-1-2-4美学指标的选取"><a href="#4-1-2-4美学指标的选取" class="headerlink" title="4-1-2-4美学指标的选取"></a>4-1-2-4美学指标的选取</h5><p>文章选取了其中四个有标准形式，具有一般性的，切能够在合理时间内计算得到的美学指标：</p>
<ul>
<li><p><strong>Crosslessness ($m_c$)</strong>：在很多研究中，边的交叉数量被作为一种最重要的审美标准，边交叉越少越好：</p>
<p>$$m_c = \begin{cases} 1 - \frac{c}{c_{max}}, &amp; \text {if $c_{max} &gt; 0$} \ 1, &amp; \text{ otherwise} \end{cases}$$</p>
<p>其中，$c$是边的交叉数，$c_{max}$是边交叉数的近似上界，被定义为：</p>
<p>$$c_{max} = \frac{|E|(|E| - 1)}{2} - \frac{1}{2}\sum_{v \in V}(deg(v)(deg(v) - 1))$$</p>
</li>
<li><p><strong>Minimum angle metric ($m_a$)</strong>：被定义为点$v$上的边的最小夹角和理想的最小夹角的平均绝对离差：</p>
<p>$$m_a = 1 = 1 - \frac{1}{|V|}\sum_{v \in V}|\frac{\theta (v) - \theta_{min}(v)}{\theta(v)}|$$</p>
<p>其中，理想最小夹角，定义为点上的所有边刚好平分360°：</p>
<p>$$\theta(v) = \frac{360°}{deg(v)}$$</p>
</li>
<li><p><strong>Edge length variation ($m_l$ )</strong>：根据边长的变异系数计算得到：</p>
<p>$$m_l = \frac{l_{cv}}{\sqrt{|E| - 1}},\quad l_{cv} = \frac{l_{\sigma}}{l_{\mu}} = \sqrt{\frac{\sum_{e \in E}(l_e - l_\mu)^2}{|E| \cdot  l_{\mu}^2}}$$</p>
<p>其中:</p>
<ul>
<li>$l_{cv}$是边长的变异系数</li>
<li>$l_\sigma$是边长的标准差</li>
<li>$l_\mu$是边长的平均值</li>
</ul>
</li>
<li><p><strong>Shape-based metric($m_s$)</strong>：可以用mean Jaccard similarity(MJS)方法，比较某个图和标准图（一般认为标准图的结构良好，属于较美的图）的相似度，定义该图的$m_s$</p>
<p>$$m_s = MJS(G_{input}, G_S), \quad MJS(G_1, G_2) = \frac{1}{|V|} \sum_{v \in V} \frac{|N_1(v) \bigcap N_2(v)|}{|N_1(v) \bigcup N_2(v)|}$$</p>
<p>其中，$G_1=(V, E_1)$和$G_2 = (V, E_2)$是所有节点都相同的两个图，$N_i(v)$是图$G_i$中$v$节点的相邻节点。采用<a href="https://en.wikipedia.org/wiki/Gabriel_graph" target="_blank" rel="external">Gabriel graph</a>作为标准图，用于比较。</p>
</li>
</ul>
<h4 id="4-1-3如何评判估算结果是否精确"><a href="#4-1-3如何评判估算结果是否精确" class="headerlink" title="4-1-3如何评判估算结果是否精确"></a>4-1-3如何评判估算结果是否精确</h4><p>为了评价在某种布局下，上述步骤<strong>估算出来的美学指标</strong>和这幅图在这种布局下<strong>实际上的美学指标</strong>的吻合情况（也就是估算精度），需要计算一下输入图$G_{input}$在经过布局方法布局后，真实的美学指标。之后，可以用以下两种方法比较<strong>估算结果</strong>和<strong>实际测量结果</strong>的吻合程度：</p>
<ul>
<li><p><strong>均方根误差（Root-Mean-Square Error (RMSE)）</strong>，结果越小越好</p>
<p>$$RMSE(\cal Y, \tilde{\cal Y}) = \sqrt{\frac{1}{n}\sum_{i}(y_i - \tilde{y_i})^2}$$</p>
<p>其中：</p>
<ul>
<li>$\cal Y = {y_1,…,y_n}$是经过实际布局后，测量出来的真实结果；</li>
<li>$\tilde{\cal Y} = {\tilde{y_1},…,\tilde{y_n}}$是回归模型的估算结果。</li>
</ul>
</li>
<li><p><strong>测定系数（coefficient of determination (R ) ）</strong>：结果越小越好</p>
<p>$$R^2(\cal Y, \tilde{\cal Y}) = 1 - \sum_{i}(y_i - \tilde{y_i})^2 / \sum_{i}(y_i - y_\mu)^2$$</p>
<p>其中$y_\mu$是测量结果$y_i$的平均值</p>
</li>
</ul>
<h4 id="4-1-4实验结果"><a href="#4-1-4实验结果" class="headerlink" title="4-1-4实验结果"></a>4-1-4实验结果</h4><h5 id="4-1-4-1估算精度方面"><a href="#4-1-4-1估算精度方面" class="headerlink" title="4-1-4-1估算精度方面"></a>4-1-4-1估算精度方面</h5><h6 id="图3：部分精度评估结果"><a href="#图3：部分精度评估结果" class="headerlink" title="图3：部分精度评估结果"></a>图3：部分精度评估结果</h6><p>上图展示了四个不同的kernel（RW-LOG-LAPLACIAN, RW-LOG-RBF, RV-LIN-COS, DGK）在八种不同的布局方法（$sfdp, FM^3, FR, KK, Spectral, HDE, Treemap, Gosper$）的四种不同美学指标（$m_c, m_a, m_l, m_s$）的两种不同估算精度度量（$RMES, R^2$）的结果。加粗部分是最佳结果。</p>
<p><img src="http://o6vut8vrh.bkt.clouddn.com/17-9-3/78771086.jpg" alt=""></p>
<ul>
<li>从上图可以看到，除了在$FM^3$布局下的$m_c$指标以外，RW-LOG-LAPLACIAN kernel的表现都是最佳。而RW-LOG-RBF kernel则在$FM^3$布局下的$m_c$指标表现最佳。DGK排名为第十二名，说明框架产生的kernel大部分都优于这个对照组，也就回答了第三个问题。</li>
<li>总体而言，RW采样方法得到的结果精确度要高于RV采样方法，LOG变换比LIN变化的精度更高，用LAPLACIAN的核也比其他两者精度更高。</li>
</ul>
<h5 id="4-1-4-2计算时间方面"><a href="#4-1-4-2计算时间方面" class="headerlink" title="4-1-4-2计算时间方面"></a>4-1-4-2计算时间方面</h5><p>因为有一些算法是并行计算的，而有一些不是。故而，这里只汇报了CPU时间。Estimation time只考虑<a href="#3-2预测图的美学指标（EAM）">预测图的美学指标</a>中提到的计算时间（不考虑训练模型的时间）。</p>
<p>结果显示，精度最高的核RW-LOG-LAPLACIAN kernel也跑的最快，平均每幅图0.14093秒（标准差为1.9559）的时间进行估算。</p>
<p>时间开销最大的是在采样图元的时候。</p>
<ul>
<li>RW采样计算速度最快，每幅图平均0.14089秒 (标准差为1.9559)。</li>
<li>DGK的图元采样速度比RW要慢，每幅图平均3.38秒（标准差为7.88）。</li>
<li>RV采样计算速度最慢，每幅图平均6.81秒（标准差为7.04）。</li>
</ul>
<h6 id="图4：计算时间和图规模之间的关系"><a href="#图4：计算时间和图规模之间的关系" class="headerlink" title="图4：计算时间和图规模之间的关系"></a>图4：计算时间和图规模之间的关系</h6><p>下图显示了拥有最高精度的RW-LOG-LAPLACIAN kernel，实际计算和估算八种布局结果以及四种美学指标的时间。左图展示了八种布局的<strong>平均实际布局时间以及估算时间（y）</strong>和图<strong>节点数量(x)</strong>之间的关系，右图则展现了不同美学指标的<strong>平均计算时间以及估算时间(y)</strong>与图<strong>节点数量（x）</strong>之间的关系。随着图的规模变大，实际布局计算时间以及美学指标的计算时间和估算时间之间也就拉开了距离。</p>
<p><img src="http://o6vut8vrh.bkt.clouddn.com/17-8-31/39145853.jpg" alt=""></p>
<h4 id="4-1-5讨论"><a href="#4-1-5讨论" class="headerlink" title="4-1-5讨论"></a>4-1-5讨论</h4><ul>
<li>RW采样方法比RV采样方法精度高，因为RW只采样连通图元，故而我们推测，连通图元对展现图的结构信息更重要，故而估算结果的精度也更高。</li>
<li>事实上，在用RV采样的过程中，每个图采样10000个图元，发现只有1.913%是连通图元，而有35.77%的图没有采样到连通图元，即便它们这些图本身都是连通的，这就使得这些图本身就很难用于比较。</li>
<li>使用LOG变换的核，比使用LIN变换的核，平均而言有着更高的估算精度，可能是因为图元的分布也经常呈现出幂率分布。</li>
<li>因为在估算过程中，不用再计算实际的布局结果，所以估算布局结果和美学指标的速度会很快。</li>
<li>发现除了DGK以外，其他核矩阵的计算时间都很短，而且相差不大，平均5.99秒，标准差3.26。而DGK因为要计算语言模型language modeling，需要平均182.96秒。</li>
</ul>
<h3 id="4-2预测图的布局结果"><a href="#4-2预测图的布局结果" class="headerlink" title="4-2预测图的布局结果"></a>4-2预测图的布局结果</h3><h4 id="4-2-1评估目的"><a href="#4-2-1评估目的" class="headerlink" title="4-2-1评估目的"></a>4-2-1评估目的</h4><p>此次评估是为了验证文章提到的<a href="#3-1预测图的布局结果（WGL）">WGL方法</a>评价出来的图和图的相似情况是否和人类心理上认为的相似情况接近。</p>
<h4 id="4-2-2实验设计"><a href="#4-2-2实验设计" class="headerlink" title="4-2-2实验设计"></a>4-2-2实验设计</h4><p>此次试验是一个排序实验，是为了比较<a href="#3-1预测图的布局结果（WGL）">WGL方法</a>得到的训练数据中的图和目标图的拓扑相似度的排序结果（$r_T$）和人类主观评价出来的相似度排序结果（$r_P$）是否匹配。</p>
<h5 id="4-2-2-1任务"><a href="#4-2-2-1任务" class="headerlink" title="4-2-2-1任务"></a>4-2-2-1任务</h5><p>如<a href="#图5：用户调研中的其中一个任务示例">图5</a>所示，参与者都会面对一个目标图（Target）和九个选项（Choices），他们需要从这些选项中，挑选出和目标最像的三个图，并按照相似度进行排序。</p>
<p>为了避免偏见，实验并没有定义什么叫做“相似”，并且也没有告诉用户，这些图都是用同一种布局方法进行布局的。</p>
<p>实验采用了九个图数据，八种布局方法进行组合，一共是72个任务。</p>
<h6 id="图5：用户调研中的其中一个任务示例"><a href="#图5：用户调研中的其中一个任务示例" class="headerlink" title="图5：用户调研中的其中一个任务示例"></a>图5：用户调研中的其中一个任务示例</h6><p>每个任务中，参与者都会面对一个目标图（Target）和九个选项（Choices），他们需要从这些选项中，挑选出和目标最像的三个图，并按照相似度进行排序。a, b, c三个图的中心节点被展示在右边。</p>
<p><img src="http://o6vut8vrh.bkt.clouddn.com/17-8-31/55830450.jpg" alt=""></p>
<h5 id="4-2-2-2图的选取"><a href="#4-2-2-2图的选取" class="headerlink" title="4-2-2-2图的选取"></a>4-2-2-2图的选取</h5><ul>
<li>目标图（Target）：一共选取了9个目标图，选择过程如下：<ol>
<li>将已有的8000+图，利用谱聚类（spectral clustering）的方法分成9类</li>
<li>对于每一类，选出相互之间拓扑相似度最高的十个图，作为这一类的代表图</li>
<li>从这十个代表图中随机挑选一个作为目标图（Target)</li>
</ol>
</li>
<li>选项图（Choice）：每幅目标图，都要挑选九幅选项图：<ol>
<li>利用每幅图和目标图之间的相似度，利用<a href="https://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization" target="_blank" rel="external">Jenks natuarak breaks方法</a>（一种一维的K均值分类方法）将所有图分成9类</li>
<li>从与目标图最相似的聚类中，选出和目标图相似度最高的图，作为其中一张选项图</li>
<li>剩余八类中，每一类都选出相互之间拓扑相似度最高的十个图，再从这十张图中随机挑选一张，作为剩余八张选项图</li>
<li>当然在挑选过程中，需要过滤掉那些节点数大于目标图两倍，或者小于目标图一半的图</li>
</ol>
</li>
</ul>
<h4 id="4-2-3实验结果"><a href="#4-2-3实验结果" class="headerlink" title="4-2-3实验结果"></a>4-2-3实验结果</h4><h6 id="图6：用户调研的总结"><a href="#图6：用户调研的总结" class="headerlink" title="图6：用户调研的总结"></a>图6：用户调研的总结</h6><p>蓝色表示用户挑选其作为最相似图的比率，绿色表示用户挑选其作为第二相似图的比率，浅绿色表示用户挑选其作为第三相似图的概率。</p>
<p>左图(a)显示了用户主观的相似图判断和算法结果的匹配程度</p>
<p>中图(b)显示了，在不同布局下，算法选出的最相似图（$r_T = 1$）和用户的选择的匹配程度</p>
<p>右图(c)显示了，对于不同的目标图，算法选出的最相似图（$r_T = 1$）和用户的选择的匹配程度</p>
<p><img src="http://o6vut8vrh.bkt.clouddn.com/17-8-31/3869351.jpg" alt=""></p>
<ul>
<li>如<a href="#图6：用户调研的总结">图6</a>，发现有80.46%的情况，参与者认为最相似的选项图（$r_P=1$）和系统选出来的最相似的图（$r_T=1$）刚好吻合（图a最左边的蓝色长条）；90.27%的情况下，参与者认为的最相似（$r_P=1$）和第二相似（$r_P=2$）的选项图和系统选出的最相似图（$r_T=1$）吻合；而93.8%的情况下，参与者选出的第1、2、3相似的图（$r_P={1,2,3}$）和系统选出的最相似图（$r_T=1$）吻合。</li>
<li>除了treemap布局和spectral布局以外，有78.52%~93.33%的情况下，参与者选出来的最相似图和算法得到的最相似图一致，有94.44%~99.26%的情况下，参与者选出来的最相似的三幅图和算法得到的最相似图吻合。</li>
<li>目标图中，除了$G_{2331}$和$G_{3833}$，有79.58%~98.33%的情况下，参与者选出来的最相似图和算法得到的最相似图一致，有92.08%~99.99%的情况下，参与者选出来的最相似的三幅图和算法得到的最相似图吻合。</li>
</ul>
<h4 id="4-2-4讨论"><a href="#4-2-4讨论" class="headerlink" title="4-2-4讨论"></a>4-2-4讨论</h4><ul>
<li>为什么Spectral和Treemap布局比其他的布局方法结果要差？<ul>
<li>spectral：参与者根据线的形状、节点的个数来判断相似程度，我们发现，谱布局，经常会有很多节点重叠，故而会让参与者判断不准</li>
<li>treemap：因为它的几何限制，经常产生相似的图形，参与者几乎都提到，“这些图怎么长的都一样？”，他们经常会根据边的密度，整体边的走向来判断相似程度，故而判断不准</li>
</ul>
</li>
<li>为什么G2331情况比较糟糕？<a href="#图5：用户调研中的其中一个任务示例">图5</a>所示情况，参与者在b和c图中徘徊不定：<ul>
<li>参与者选择c的原因：密度、形状、边的数量</li>
<li>参与者选择b的原因：中心节点的数量</li>
<li>系统选择c的原因：大体上结构和目标相似</li>
</ul>
</li>
</ul>
<h2 id="五、讨论"><a href="#五、讨论" class="headerlink" title="五、讨论"></a>五、讨论</h2><p><img src="http://o6vut8vrh.bkt.clouddn.com/17-9-3/42643278.jpg" alt=""></p>
<p>上图是8263幅图用RW-LOG-LAPLACIAN kernel计算得到的相似度的一个投影，这一对对的图是9对拓扑结构最相似但却非同构的图。</p>
<p>这篇论文，为我们进行大图可视化提供了一个新的思路，为了应对大图中高的计算代价，可以通过机器学习的方法，用预计算的代价来代替实时计算。这样就甚至能把大图的某些计算效率提高到实时的级别。</p>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/blog/2017/10/03/WeiweiCui的图可视化综述阅读笔记/" data-toggle="tooltip" data-placement="top"
                           title="WeiweiCui的图可视化综述阅读笔记">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/blog/2017/08/21/Python入门学习笔记/" data-toggle="tooltip" data-placement="top"
                           title="Python入门学习笔记基础">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                
                <!-- 来必力City版安装代码 -->
                <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTk2MC82NTI1">
                    <script type="text/javascript">
                        (function(d, s) {
                            var j, e = d.getElementsByTagName(s)[0];

                            if (typeof LivereTower === 'function') { return; }

                            j = d.createElement(s);
                            j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                            j.async = true;

                            e.parentNode.insertBefore(j, e);
                        })(document, 'script');
                    </script>
                    <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
                </div>
                <!-- City版安装代码已完成 -->
                
            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#机器学习的方法来帮助进行大图可视化"><span class="toc-text">机器学习的方法来帮助进行大图可视化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、介绍"><span class="toc-text">一、介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑相似度比较方法——graph-kernel"><span class="toc-text">拓扑相似度比较方法——graph kernel</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#图1：3、4、5节点的所有连通的图元"><span class="toc-text">图1：3、4、5节点的所有连通的图元</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、方法"><span class="toc-text">二、方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设计graphlet-kernel的框架"><span class="toc-text">设计graphlet kernel的框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1采样图元"><span class="toc-text">2-1采样图元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2计算图元频率向量"><span class="toc-text">2-2计算图元频率向量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3定义内积"><span class="toc-text">2-3定义内积</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、用途"><span class="toc-text">三、用途</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1预测图的布局结果（WGL）"><span class="toc-text">3-1预测图的布局结果（WGL）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#图2：图元频率分布的四个例子"><span class="toc-text">图2：图元频率分布的四个例子</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2预测图的美学指标（EAM）"><span class="toc-text">3-2预测图的美学指标（EAM）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、评估"><span class="toc-text">四、评估</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1估算布局的美学指标"><span class="toc-text">4-1估算布局的美学指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1评估目的"><span class="toc-text">4-1-1评估目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2实验设计"><span class="toc-text">4-1-2实验设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-1数据集"><span class="toc-text">4-1-2-1数据集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-2kernel选取"><span class="toc-text">4-1-2-2kernel选取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-3布局方法选取"><span class="toc-text">4-1-2-3布局方法选取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-4美学指标的选取"><span class="toc-text">4-1-2-4美学指标的选取</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3如何评判估算结果是否精确"><span class="toc-text">4-1-3如何评判估算结果是否精确</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4实验结果"><span class="toc-text">4-1-4实验结果</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-4-1估算精度方面"><span class="toc-text">4-1-4-1估算精度方面</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#图3：部分精度评估结果"><span class="toc-text">图3：部分精度评估结果</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-4-2计算时间方面"><span class="toc-text">4-1-4-2计算时间方面</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#图4：计算时间和图规模之间的关系"><span class="toc-text">图4：计算时间和图规模之间的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5讨论"><span class="toc-text">4-1-5讨论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2预测图的布局结果"><span class="toc-text">4-2预测图的布局结果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1评估目的"><span class="toc-text">4-2-1评估目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2实验设计"><span class="toc-text">4-2-2实验设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-1任务"><span class="toc-text">4-2-2-1任务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#图5：用户调研中的其中一个任务示例"><span class="toc-text">图5：用户调研中的其中一个任务示例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-2图的选取"><span class="toc-text">4-2-2-2图的选取</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3实验结果"><span class="toc-text">4-2-3实验结果</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#图6：用户调研的总结"><span class="toc-text">图6：用户调研的总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4讨论"><span class="toc-text">4-2-4讨论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、讨论"><span class="toc-text">五、讨论</span></a></li></ol></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/blog/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/blog/tags/#可视化"
                           title="可视化">可视化</a>
                        
                        <a class="tag" href="/blog/tags/#论文"
                           title="论文">论文</a>
                        
                        <a class="tag" href="/blog/tags/#阅读笔记"
                           title="阅读笔记">阅读笔记</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/deepfeel-anxis">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/JackieAnxis">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 咸鱼Jackie 2018
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/blog/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/blog/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/blog/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://jackieanxis.github.io/blog/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->

<script>
    var _baId = '46a3d5833f277ac4dc2a9cf1285413de';
    // Originial
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?" + _baId;
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','null','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="http://o6vut8vrh.bkt.clouddn.com/17-1-24/89289633-file_1485227996130_e75a.jpg">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>

</html>
